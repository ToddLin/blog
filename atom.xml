<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Todd&#39;s Blog</title>
  
  <subtitle>Todd&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.toddlin.site/"/>
  <updated>2018-09-18T13:56:52.051Z</updated>
  <id>https://blog.toddlin.site/</id>
  
  <author>
    <name>Todd Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#之XML反序列化的一些坑</title>
    <link href="https://blog.toddlin.site/2018/09/xml-serialize/"/>
    <id>https://blog.toddlin.site/2018/09/xml-serialize/</id>
    <published>2018-09-17T04:59:14.000Z</published>
    <updated>2018-09-18T13:56:52.051Z</updated>
    
    <content type="html"><![CDATA[<p>本文首次发布在博客<strong>[<a href="https://blog.toddlin.site/2018/09/xml-serialize/">C#之XML反序列化的一些坑</a>]</strong></p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>我们在.net平台反序列化一份xml文档的时候经常性的会遇到一些很奇怪的问题，要么在反序列化过程中抛出各种异常，要么没有发生异常，可结果却不是我们想要的。抛异常的情况倒是比较容易解决，根据异常信息自己找MSDN文档或者Google搜索，一般都能找到解决办法。麻烦的是没有异常结果却不理想的情况，这种情况往往需要一步步调试跟踪代码，但是微软的底层已经封装，调试起来很困难。</p><p>下面是我在反序列化的时候遇到过的一些坑。先上一段需要反序列化的代码。</p><h5 id="目标XML"><a href="#目标XML" class="headerlink" title="目标XML"></a>目标XML</h5><pre><code>&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;soapenv:Envelope    xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;    &lt;soapenv:Body&gt;        &lt;xsd:DestinationListResponse            xmlns:xsd=&quot;http://response.example.com/xsd&quot;&gt;            &lt;xsd:success&gt;true&lt;/xsd:success&gt;            &lt;xsd:country xsd1:id=&quot;1933312&quot; xsd1:name=&quot;Afghanistan&quot; xsd1:nameEn=&quot;Afghanistan&quot; xsd:isoCode=&quot;AF&quot;                xmlns:xsd1=&quot;http://types.example.com/xsd&quot;&gt;                &lt;xsd:city xsd1:id=&quot;1934162&quot; xsd1:name=&quot;Kabul&quot; xsd1:nameEn=&quot;Kabul&quot; xsd:isoCode=&quot;KBL&quot; xsd:latitude=&quot;34.53333282470703&quot; xsd:longitude=&quot;69.16666412353516&quot;/&gt;            &lt;/xsd:country&gt;            &lt;xsd:country xsd1:id=&quot;1933313&quot; xsd1:name=&quot;Albania&quot; xsd1:nameEn=&quot;Albania&quot; xsd:isoCode=&quot;AL&quot;                xmlns:xsd1=&quot;http://types.example.com/xsd&quot;&gt;                &lt;xsd:city xsd1:id=&quot;31959649&quot; xsd1:name=&quot;Durres&quot; xsd1:nameEn=&quot;Durres&quot; xsd:isoCode=&quot;TIA&quot; xsd:latitude=&quot;41.31666564941406&quot; xsd:longitude=&quot;19.450000762939453&quot;/&gt;                &lt;xsd:city xsd1:id=&quot;50001732&quot; xsd1:name=&quot;Pogradec&quot; xsd1:nameEn=&quot;Pogradec&quot; xsd:isoCode=&quot;&quot; xsd:latitude=&quot;40.900001525878906&quot; xsd:longitude=&quot;20.649999618530273&quot;/&gt;            &lt;/xsd:country&gt;        &lt;/xsd:DestinationListResponse&gt;    &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</code></pre><p>这一段XML，相信大家都能看懂。这里涉及到几个XML的概念如下：声明、名称空间、前缀、元素、属性。对这几个概念不了解的自行Google。了解这几个概念之后，构建C#实体类就很简单了，复杂元素构建成类，简单元素和属性作为类的字段。我创建了对应的实体类之后开始反序列化就遇到了一些问题。</p><h5 id="一、获取SOAP中Body里的内容报错或者为空"><a href="#一、获取SOAP中Body里的内容报错或者为空" class="headerlink" title="一、获取SOAP中Body里的内容报错或者为空"></a>一、获取SOAP中Body里的内容报错或者为空</h5><p>我这里需要获取<code>DestinationListResponse</code>元素反序列化成我建的对应的C#实体DestinationListResponse类的对象。代码如下：</p><pre><code>XmlDocument doc = new XmlDocument();doc.LoadXml(xml);var node = doc.SelectSingleNode(&quot;//Body&quot;);var innerXml = node.InnerXml;</code></pre><p>这样没有报错，但是获取到<code>node</code>的值=null。然后我把<code>var node = doc.SelectSingleNode(&quot;//Body&quot;);</code>这句代码改成<code>var node = doc.SelectSingleNode(&quot;//soapenv:Body&quot;);</code>之后再调试。这句代码直接就抛出异常了，提示类似缺少名称空间之类的信息。然后我发现<code>SelectSingleNode</code>正好有个参数类型是管理名称空间的，我就在这句代码之前把所有名称空间全部加上，最后完整的代码就长这样：</p><pre><code>XmlDocument doc = new XmlDocument();        doc.LoadXml(xml); XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);        nsmgr.AddNamespace(&quot;soapenv&quot;, &quot;http://schemas.xmlsoap.org/soap/envelope/&quot;);        nsmgr.AddNamespace(&quot;xsd&quot;, &quot;http://response.example.com/xsd&quot;);        nsmgr.AddNamespace(&quot;xsd1&quot;, &quot;http://types.example.com/xsd&quot;);        var node = doc.SelectSingleNode(&quot;//soapenv:Body&quot;);        var innerXml = node.InnerXml;</code></pre><p>这下，终于<code>node</code>终于有值了。然后我藏尸着不把名称空间全部加上，少一个或者两个，<code>SelectSingleNode</code>方法都会抛异常。我又尝试着把这句代码改成<code>var node = doc.SelectSingleNode(&quot;//Body&quot;);</code>,<code>node</code>的值还是null。</p><p>以上得出：</p><ol><li>XML有名称空间时必须把所有名称空间通过<code>XmlNamespaceManager</code>管理起来传入方法<code>SelectSingleNode</code>中。</li><li>xml节点有前缀时，获取节点必须带前缀，如<code>doc.SelectSingleNode(&quot;//soapenv:Body&quot;)</code>而不能是<code>doc.SelectSingleNode(&quot;//Body&quot;)</code>。</li></ol><h5 id="二、反序列化XML之后-集合元素对应的字段的值为空"><a href="#二、反序列化XML之后-集合元素对应的字段的值为空" class="headerlink" title="二、反序列化XML之后,集合元素对应的字段的值为空"></a>二、反序列化XML之后,集合元素对应的字段的值为空</h5><p>如目标XML中city元素是多个一组的，我称之为集合元素。对应的实体类型的字段也应该是集合类型的，我首先想到的就是使用数组，给字段标记<code>XmlArray</code>特性，如下：</p><pre><code>[XmlArray][XmlArrayItem(ElementName =&quot;city&quot;)]public CityClass[] CityArr { get; set; }</code></pre><p>但是，这样定义的字段在反序列化XML之后<code>CityArr</code>的值是<code>null</code>的，必须改成下面这样的才能正确的得到<code>city</code>元素的内容</p><pre><code>[XmlElement(ElementName = &quot;city&quot;)]public CityClass[] CityArr { get; set; }</code></pre><h5 id="三、反序列化XML之后-含前缀的元素的属性对应的字段的值为空"><a href="#三、反序列化XML之后-含前缀的元素的属性对应的字段的值为空" class="headerlink" title="三、反序列化XML之后,含前缀的元素的属性对应的字段的值为空"></a>三、反序列化XML之后,含前缀的元素的属性对应的字段的值为空</h5><p>出现这种情况，大概率有2个原因。</p><ol><li>实体类没有指定名称空间</li><li>实体类字段没有指定强制使用名称空间前缀</li></ol><p>如目标XML所有元素都有前缀，而且前缀还不一样，有<code>xsd</code>和<code>xsd1</code>。前缀和名称空间是一一对应的，目标XML中<code>xsd</code>前缀对应<code>http://response.example.com/xsd</code>名称空间，<code>xsd1</code>前缀对应<code>http://types.example.com/xsd</code>名称空间。如<code>city</code>元素的前缀是<code>xsd</code>。那么它对应的实体就要像下面这样加上名称空间。</p><pre><code>[Serializable][XmlType(Namespace = &quot;http://response.example.com/xsd&quot;)]public class CityClass{    [XmlAttribute(Form = XmlSchemaForm.Qualified)]    public string isoCode { get; set; }    ......}</code></pre><p>这段代码中<code>isoCode</code>的<code>XmlAttribute</code>特性加了一句代码<code>Form = XmlSchemaForm.Qualified</code> 它的作用就是强制使用名称空间前缀的意思。如果xml文档的元素或者元素属性有前缀，那么加上这句就可以正确的反序列化了。不过，如果是元素的化，好像不加这句也没有什么影响。</p><h3 id="以上所有提及的序列化反序列化均是指使用微软-net平台System-Xml-Serialization命名空间中的类实现的操作。"><a href="#以上所有提及的序列化反序列化均是指使用微软-net平台System-Xml-Serialization命名空间中的类实现的操作。" class="headerlink" title="以上所有提及的序列化反序列化均是指使用微软.net平台System.Xml.Serialization命名空间中的类实现的操作。"></a>以上所有提及的序列化反序列化均是指使用微软.net平台System.Xml.Serialization命名空间中的类实现的操作。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首次发布在博客&lt;strong&gt;[&lt;a href=&quot;https://blog.toddlin.site/2018/09/xml-serialize/&quot;&gt;C#之XML反序列化的一些坑&lt;/a&gt;]&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; c
      
    
    </summary>
    
      <category term=".net" scheme="https://blog.toddlin.site/categories/net/"/>
    
    
      <category term="xml" scheme="https://blog.toddlin.site/tags/xml/"/>
    
      <category term="serialize" scheme="https://blog.toddlin.site/tags/serialize/"/>
    
  </entry>
  
</feed>
